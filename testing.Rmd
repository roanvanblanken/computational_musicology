---
title: "Themed dashboard"
output: 
  flexdashboard::flex_dashboard:
    theme:
      base_font:
        google: Prompt
      code_font:
        google: JetBrains Mono
    orientation: columns
    vertical_layout: fill
---

```{r setup, include=FALSE}
library(flexdashboard)
library(flexdashboard)
library(spotifyr)
library(purrr)
library(dplyr)
library(ggplot2)
library(plotly)
library(tidyverse)
library(compmus)

# Get playlists
songs_i_like <- get_playlist_audio_features("", "6pl0C7qbIl5uoY3Tdf82oa")

songs_i_like <- songs_i_like %>%
  mutate(mode = ifelse(mode == 0, "Minor", "Major"))

songs_i_dislike <- get_playlist_audio_features("", "4bJQX5w7W4wEnHLmWqUIVY")

songs_i_dislike <- songs_i_dislike %>%
  mutate(mode = ifelse(mode == 0, "Minor", "Major"))
```

Track-Level Summary {data-icon="fas fa-music"}
=====================================

Overview
--------------------------------------------------

### Outliers

The selection of an appropriate corpus is essential to effectively achieve research objectives. In this study, a broad corpus was chosen that included diverse data related to the research question. However, the large volume of data made it difficult to identify significant patterns or trends that could adequately address the research question.

To overcome this challenge, the decision was made to focus on the outliers in the corpus. Specifically, the analysis focused on the extreme cases that were most divergent from the norm in terms of a specific timbre component. This approach allowed for the isolation and study of the outliers, leading to valuable insights and a better understanding of the factors contributing to their unique timbre characteristics. Ultimately, this approach strengthened the analysis and enhanced the quality of the research findings.

Timbre, the quality of sound that distinguishes different musical instruments, is a crucial aspect of music. The analysis of timbre is often performed using spectral content, which measures the relative strengths of various frequency components that make up the sound. In this study, the focus was on a specific timbre component, which was used to isolate and study the outliers in the corpus.

By examining the plot, it can be observed that there are four outliers, with two in each playlist. Specifically, in the **'Songs I like'** playlist, the song 'Jungle' exhibits the highest timbre in the c02 vector, whereas 'Engravings' has the lowest. In contrast, in the **'Songs I dislike'** playlist, 'Murder' has the highest timbre in the c02 vector, while '19 Tini 5' has the lowest.

Column 2 {.tabset}
--------------------------------------------------

### Timbre components

```{r summary_2}
cdata <- readRDS(file="timbre_data.Rda")

plot1 <- cdata %>%
  ggplot(aes(x = factor(basis), y = value, fill = Playlist)) +
  geom_violin() +
  scale_fill_viridis_d() +
  geom_text(data = . %>% filter(Playlist == "Songs I like" & basis == 'c02') %>% filter(value == min(value)), aes(label = track.name), position = position_nudge(x = 1.3, y = -0.3), color = "darkgoldenrod", size = 4, fontface = "bold") +
  geom_text(data = . %>% filter(Playlist == "Songs I like" & basis == 'c02') %>% filter(value == max(value)), aes(label = track.name), position = position_nudge(x = 1.2, y = 0), color = "darkgoldenrod", size = 4, fontface = "bold") +
  geom_text(data = . %>% filter(Playlist == "Songs I dislike" & basis == 'c02') %>% filter(value == min(value)), aes(label = track.name), position = position_nudge(x = 0.6, y = 0.3), color = "darkviolet", size = 4, fontface = "bold") +
  geom_text(data = . %>% filter(Playlist == "Songs I dislike" & basis == 'c02') %>% filter(value == max(value)), aes(label = track.name), position = position_nudge(x = 2.8, y = 0.3), color = "darkviolet", size = 4, fontface = "bold") +
  labs(x = "Spotify Timbre Coefficients", y = "", fill = "Playlist") +
  theme_minimal()

ggplotly(plot1)
```

### c01

```{r c01}
# Create table for c01
cdata <- readRDS(file="timbre_data.Rda")

table_c01 <- cdata %>%
  filter(basis == "c01") %>%
  group_by(Playlist) %>%
  slice_min(value, n = 1) %>%
  bind_rows(cdata %>%
              filter(basis == "c01") %>%
              group_by(Playlist) %>%
              slice_max(value, n = 1)) %>%
  select(Playlist, track.name, artists, value) %>%
  rename("Track" = "track.name", "Artists" = "artists")

knitr::kable(table_c01, caption = "Table of maximum and minimum values of c01 for each playlist")

```

### c02

```{r c02}
# Create table for c02
cdata <- readRDS(file="timbre_data.Rda")

table_c02 <- cdata %>%
  filter(basis == "c02") %>%
  group_by(Playlist) %>%
  slice_min(value, n = 1) %>%
  bind_rows(cdata %>%
              filter(basis == "c02") %>%
              group_by(Playlist) %>%
              slice_max(value, n = 1)) %>%
  select(Playlist, track.name, artists, value) %>%
  rename("Track" = "track.name", "Artists" = "artists")

knitr::kable(table_c02, caption = "Table of maximum and minimum values of c02 for each playlist")
```

### c03

```{r c03}
# Create table for c03
cdata <- readRDS(file="timbre_data.Rda")

table_c03 <- cdata %>%
  filter(basis == "c03") %>%
  group_by(Playlist) %>%
  slice_min(value, n = 1) %>%
  bind_rows(cdata %>%
              filter(basis == "c03") %>%
              group_by(Playlist) %>%
              slice_max(value, n = 1)) %>%
  select(Playlist, track.name, artists, value) %>%
  rename("Track" = "track.name", "Artists" = "artists")

knitr::kable(table_c03, caption = "Table of maximum and minimum values of c03 for each playlist")
```

### c04

```{r c04}
# Create table for c04
cdata <- readRDS(file="timbre_data.Rda")

table_c04 <- cdata %>%
  filter(basis == "c04") %>%
  group_by(Playlist) %>%
  slice_min(value, n = 1) %>%
  bind_rows(cdata %>%
              filter(basis == "c04") %>%
              group_by(Playlist) %>%
              slice_max(value, n = 1)) %>%
  select(Playlist, track.name, artists, value) %>%
  rename("Track" = "track.name", "Artists" = "artists")

knitr::kable(table_c04, caption = "Table of maximum and minimum values of c04 for each playlist")
```

Tempograms {data-icon="fas fa-drum"}
=====================================

Overview
--------------------------------------------------

### Chart A

For the Tempograms, I selected the two songs from the 'Songs I like' playlist with the highest and lowest c01 components based on the track-level-summary (see [track-level-summary](index.html#track-level-summary)). Specifically, I chose 'Africa' by Toto with the highest c01 value, and 'Starstruck' by Years & Years with the lowest c01 value. This selection was made to investigate potential differences in tempo between the songs.

From the plots, it can be observed that both songs have a relatively steady tempo with occasional variations. However, 'Starstruck' exhibits more frequent tempo changes, which can be explained by its lower c01 timbre component. The c01 component measures the overall loudness of the song.

In conclusion, the selection of songs based on their c01 component values allowed for an exploration of potential differences in tempo patterns and provided insights into the relationship between c01 values and overall loudness. Additionally, it is worth noting that I tend to prefer songs with a consistent tempo, which may explain my personal preference for songs with similar overall tempos.

Column 2
--------------------------------------------------

### 

```{r tempogram_1}
# Define a custom color palette
blues_purples <- colorRampPalette(c("#2c7bb6", "#abdda4", "#ffffbf", "#fdae61", "#d7191c"))(100)


starstruck_cyclic <- readRDS(file="starstruck_cyclic (Tempogram).Rda")

tempogram_1 <- starstruck_cyclic |>
  ggplot(aes(x = time, y = bpm, fill = power)) +
  geom_raster() +
  ggtitle("Cyclic Tempogram - Years & Years: 'Starstruck'") +
  scale_fill_gradientn(colors = blues_purples) +
  labs(x = "Time (s)", y = "Tempo (BPM)") +
  theme_minimal() +
  scale_color_gradientn(colors = blues_purples)

ggplotly(tempogram_1, tooltip = "none", source = "none")
```

### 

```{r tempogram_2}
# Define a custom color palette
blues_purples <- colorRampPalette(c("#2c7bb6", "#abdda4", "#ffffbf", "#fdae61", "#d7191c"))(100)

africa_cyclic <- readRDS(file="africa_cyclic (Tempogram).Rda")

tempogram_2 <- africa_cyclic |>
  ggplot(aes(x = time, y = bpm, fill = power)) +
  geom_raster() +
  ggtitle("Cyclic Tempogram - Africa: 'Toto'") +
  scale_fill_gradientn(colors = blues_purples) +
  labs(x = "Time (s)", y = "Tempo (BPM)") +
  theme_minimal() +
  scale_color_gradientn(colors = blues_purples)

ggplotly(tempogram_2, tooltip = "none", source = "none")
```